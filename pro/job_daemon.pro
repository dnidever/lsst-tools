;+
;
; JOB_DAEMON
;
; This program is the daemon for photred.  It controls pleione jobs.
; See daophot_setup.pro for how to make the pleione scripts
;
; If we are running on Pleione, multiple jobs is turned on, and multiple
; jobs are input then run the daemon, otherwise just run single jobs
;
; NOTE:  If you want to "kill" all of the jobs create a file "killjobs"
; in the same directory that JOB_DAEMON is being run in and all of the
; PBS jobs will be killed.
;
; INPUTS:
;  input     A string array with the IDL commands (i.e. jobs) to be run.
;  dirs      The directories in which the commands are to be run.
;  /idle     This is an IDL command, otherwise a SHELL command.
;  =prefix   The prefix for the PBS script names
;  =nmulti   How many nodes to run these jobs on.  Default is 8.
;  /hyperthread  Not on a PBS server but one that has multiple processors
;                 hyperthreaded.  Run multiple jobs at the same time on
;                 the same server.
;  =inpname  The name to be used for the script (without the path or
;              the .sh/.batch ending.  This is normally autogenerated.
;  =statustime   The time between status updates.  However, the status
;                  will always be updated if something has actually changed.
;  =waittime     Time to wait between checking the running jobs.  Default
;                is 0.2 sec.
;
; OUTPUTS:
;  =jobs      The jobs structure with information on the JOBID, script
;               name, etc.
;  Jobs are run in a batch mode.
;
; USAGE:
;  IDL>job_daemon,input,dirs,jobs=jobs,idle=idle,prefix=prefix,nmulti=nmulti
;
; By D.Nidever   February 2008
;   Modified for LSST stack   Nov 2015
;-

pro job_daemon,input,dirs,jobs=jobs,idle=idle,prefix=prefix,nmulti=nmulti,$
               hyperthread=hyperthread,waittime=waittime,statustime=statustime,$
               inpname=inpname,cdtodir=cdtodir,error=error

lsst_undefine,jobs,error
  
; How many input lines
ninput = n_elements(input)
if ninput eq 0 then begin
  error = 'Not enough inputs'
  print,'Syntax - job_daemon,input,dirs,jobs=jobs,idle=idle,prefix=prefix,nmulti=nmulti,'
  print,'                    hyperthread=hyperthread,waittime=waittime,statustime=statustime,'
  print,'                    inpname=inpname,error=error'
  return
endif

; Current directory
CD,current=curdir

; Checking DIRS array
ndirs = n_elements(dirs)
if ndirs gt 0 then if ndirs ne ninput then begin
  error = 'DIRS array must be same size as INPUT'
  print,error
  return
endif
if ndirs eq 0 then dirs = replicate(curdir,ninput)
if ndirs eq 1 then dirs = replicate(dirs,ninput)

; Check INPNAME array
ninpname = n_elements(inpname)
if ninpname gt 0 then if ninpname ne ninput then begin
  error = 'INPNAME array must be same size as INPUT'
  print,error
  return
endif

; Defaults
if n_elements(nmulti) eq 0 then nmulti=8           ; number of jobs to submit at a time
if n_elements(waittime) eq 0 then waittime=0.2     ; wait time
waittime = waittime > 0.1
if n_elements(statustime) eq 0 then statustime=60  ; status time
statustime = statustime > 1

; Host name
host = getenv('HOST')

; Which IDL are we using?
if keyword_set(idle) then begin
  SPAWN,['which','idl'],out,errout,/noshell
  if STRPOS(out[0],'aliased to') ne -1 then $
    out = first_el(strsplit(out[0],' ',/extract),/last)
  idlprog = FILE_SEARCH(out[0],count=nidlprog)
  if (nidlprog eq 0) then begin
    error = 'IDL PROGRAM NOT AVAILABLE'
    print,error
    return
  endif
endif

; Create RUNBATCH and IDLBATCH if using /hyperthread
if keyword_set(hyperthread) then begin
  if not keyword_set(idle) and FILE_TEST('runbatch') eq 0 then begin
    undefine,lines
    push,lines,"if test $# -eq 0"
    push,lines,"then"
    push,lines,"  echo 'Syntax - runbatch program'"
    push,lines,"else"
    push,lines,"  echo 'Log file: '$1'.log'"
    push,lines,"  ( nohup  $1 > $1.log 2>&1 ) &"
    push,lines,"  echo JOBID=$!"
    ;push,lines,"  echo $!"
    push,lines,"fi"
    WRITELINE,'runbatch',lines
    FILE_CHMOD,'runbatch','755'o
  endif
  if keyword_set(idle) and FILE_TEST('idlbatch') eq 0 then begin
    undefine,lines
    push,lines,"if test $# -eq 0"
    push,lines,"then"
    push,lines,"  echo 'Syntax - idlbatch idl.batch'"
    push,lines,"else"
    push,lines,"  echo 'Log file: '$1'.log'"
    push,lines,"  ( nohup "+idlprog+" < $1 > $1.log 2>&1 ) &"
    push,lines,"  echo JOBID=$!"
    ;push,lines,"  echo $!"
    push,lines,"fi"
    WRITELINE,'idlbatch',lines
    FILE_CHMOD,'idlbatch','755'o
  endif
endif


print,'---------------------------------'
print,' RUNNING JOB_DAEMON for ',strtrim(ninput,2),' JOB(S)'
print,'---------------------------------'
print,'Host=',host
print,'Nmulti=',strtrim(nmulti,2)

timesincelaststatus = systime(/julian,/utc)  ; initializing the update time


;--------
; DAEMON
;--------

; -Keep submitting jobs until nmulti is reached
; -Check every minute or so to see how many jobs are still
;  running.  If it falls below nmulti and more jobs are left then
;  submit more jobs
; -Don't return until all jobs are done.


; Initialize the "jobs" structure
; id will be the ID from Pleione
dum = {host:host,jobid:'',input:'',dir:'',name:'',scriptname:'',logfile:'',submitted:0,done:0,$
       begtime:0.0d0,endtime:0.0d0,duration:0.0}
jobs = replicate(dum,ninput)
jobs.input = input
njobs = ninput

; Loop until all jobs are done
; On each loop check the pleione queue and figure out what to do
count = 0LL
endflag = 0
WHILE (endflag eq 0) DO BEGIN

  ; Status update
  dtstatus_sec = ( systime(/julian,/utc)-timesincelaststatus )*3600L*24L
  if dtstatus_sec ge statustime then begin
    updatestatus = 1
    timesincelaststatus = systime(/julian,/utc)
    print,'' & print,systime(0)
  endif else updatestatus=0
  
  ; Check disk space
  ;-----------------
  ;SPAWN,'df -k '+dirs[0],dfout,dfouterr
  ; Linux
  ;SPAWN,'df -B 1M '+dirs[0],dfout,dfouterr
  ; Mac OS X
  SPAWN,['df','-m',dirs[0]],dfout,dfouterr,/noshell
  dfarr = strsplitter(dfout,' ',/extract)
  nline = n_elements(dfout)
  available = float(reform(dfarr[3,nline-1]))
  ;available = float(reform(dfarr[2,nline-1]))
  if updatestatus then print,'Disk Space: ',strtrim(available[0],2),' MB available'
  ; Not enough disk space available
  if available[0] lt 100. then begin
    error = 'NOT enough disk space available'
    print,error
    return
  endif


  ; Check for kill file
  ;--------------------
  kill = FILE_TEST('killjobs')
  if (kill eq 1) then begin
    sub = where(jobs.submitted eq 1 and jobs.done eq 0,nsub)

    print,'Kill file found.  Killing all ',strtrim(nsub,2),' job(s)'

    for i=0,nsub-1 do begin
      ; Killing the job
      print,'Killing ',jobs[sub[i]].name,'  JobID=',jobs[sub[i]].jobid

      if not keyword_set(hyperthread) then begin
        SPAWN,['qdel',jobs[sub[i]].jobid],out,errout,/noshell
      endif else begin
        SPAWN,['kill','-9',jobs[sub[i]].jobid],out,errout,/noshell
      endelse
    endfor

    ; Remove the kill file
    print,'Deleting kill file "killjobs"'
    FILE_DELETE,'killjobs',/allow,/quiet

    ; Now exit
    return
  endif

  
  ; Check status of running jobs
  ;-----------------------------
  sub = where(jobs.submitted eq 1 and jobs.done eq 0,nsub)
  for i=0,nsub-1 do begin

    ; Checking status
    jobid = jobs[sub[i]].jobid
    JOB_CHECKSTAT,statstr,jobid=jobid,hyperthread=hyperthread

    ; Job done
    if statstr.jobid eq '' then begin
      print,systime(0)+'  Input ',strtrim(sub[i]+1,2),' ',jobs[sub[i]].name,' JobID=',jobs[sub[i]].jobid,' FINISHED'
      jobs[sub[i]].done=1
      jobs[sub[i]].endtime = systime(/julian,/utc)
      jobs[sub[i]].duration = ( jobs[sub[i]].endtime - jobs[sub[i]].begtime )*3600*24 ; in sec
    endif

    ; Check for errors as well!! and put in jobs structure
  endfor

  ; Current status
  ;---------------
  dum = where(jobs.submitted eq 1 and jobs.done eq 0,Ninqueue)  ; Number of jobs still in queue
  dum = where(jobs.submitted eq 0,Nnosubmit)                    ; Number of jobs left to do
  dum = where(jobs.done eq 1,nfinished)                         ; Number of jobs finished
  ; Print the status
  if updatestatus then print,'Jobs Summary: ',strtrim(ninput,2),' total, ',strtrim(nfinished,2),$
                             ' finished, ',strtrim(Ninqueue,2),' running, ',strtrim(Nnosubmit,2),' left'

  ; Submit new jobs
  ;----------------
  Nnew = (nmulti-ninqueue) > 0
  Nnew = Nnew < Nnosubmit
  If (Nnew gt 0) then begin

    ; Get the indices of new jobs to be submitted
    nosubmit = where(jobs.submitted eq 0)
    newind = nosubmit[0:nnew-1]

    ; Update immediately if there are new jobs to submit
    print,''
    print,systime(0)
    print,'Updating Queue: '+strtrim(ninqueue,2),' JOB(S) running, out of ',strtrim(nmulti,2),' Maximum. '+$
      'Submitting ',strtrim(nnew,2),' more job(s)'

    ; Loop through the new submits
    For i=0,nnew-1 do begin

      print,''
      cmd = jobs[newind[i]].input
      if keyword_set(idle) then cmd='IDL>'+cmd
      ; Update immediately
      print,'Input ',strtrim(newind[i]+1,2),'  Command: >>',cmd,'<<'

      ; Make script
      lsst_undefine,name,scriptname
      if ninpname gt 0 then name=inpname[newind[i]]  ; use input name
      JOB_MAKESCRIPT,jobs[newind[i]].input,dir=dirs[newind[i]],name=name,scriptname=scriptname,$
                     prefix=prefix,idle=idle,hyperthread=hyperthread
      ; Check that the script exists
      test = FILE_TEST(scriptname)

      ; Submitting the job
      if not keyword_set(hyperthread) then begin
        SPAWN,['qsub',scriptname[0]],out,errout,/noshell
        jobid = reform(out[0])
        logfile = scriptname[0]+'.log'
      endif else begin
        if keyword_set(idle) then batchprog='./idlbatch' else batchprog='./runbatch'  ; use local version
        if keyword_set(cdtodir) then cd,dirs[newind[i]]
        SPAWN,[batchprog,scriptname[0]],out,errout,/noshell
        if keyword_set(cdtodir) then cd,curdir
        ; Get the JOBID
        jobid_ind = where(stregex(out,'^JOBID=',/boolean) eq 1,njobid_ind)
        jobid = strmid(out[jobid_ind[0]],6)        
        ; Get the logfile
        logfile_ind = where(stregex(out,'^Log file: ',/boolean) eq 1,nlogfile_ind)
        logfile = strmid(out[logfile_ind[0]],10)
     endelse

      ; Check that there weren't any errors
      dum = where(errout ne '',nerror)

      ; Printing info
      print,'Submitted ',scriptname[0],'  JobID=',jobid[0]

      ; Updating the jobs structure
      jobs[newind[i]].submitted = 1
      jobs[newind[i]].jobid = jobid
      jobs[newind[i]].name = name[0]
      jobs[newind[i]].dir = dirs[newind[i]]
      jobs[newind[i]].scriptname = scriptname[0]
      jobs[newind[i]].logfile = logfile
      jobs[newind[i]].begtime = systime(/julian,/utc)
      
    Endfor  ; submitting new jobs loop
    print,''
  Endif  ; new jobs to submit

  ; Are we done?
  ;-------------
  dum = where(jobs.done eq 1,ndone)
  if ndone eq njobs then endflag=1

  ; Wait a bit
  ;--------------
  if endflag eq 0 then wait,waittime

  ; Increment the counter
  count++

ENDWHILE  ; time loop

if keyword_set(stp) then stop

end
